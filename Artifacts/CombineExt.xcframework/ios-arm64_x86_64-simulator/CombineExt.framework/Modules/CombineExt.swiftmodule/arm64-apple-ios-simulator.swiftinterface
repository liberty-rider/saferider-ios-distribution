// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
// swift-module-flags: -target arm64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name CombineExt
import Combine
import Darwin
@_exported import Foundation
import Foundation/*.NSRecursiveLock*/
import Swift
import _Concurrency
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Optional {
  @available(macOS, obsoleted: 11.0, message: "Optional.publisher is now part of Combine.")
  @available(iOS, obsoleted: 14.0, message: "Optional.publisher is now part of Combine.")
  @available(tvOS, obsoleted: 14.0, message: "Optional.publisher is now part of Combine.")
  @available(watchOS, obsoleted: 7.0, message: "Optional.publisher is now part of Combine.")
  public var publisher: Swift.Optional<Wrapped>.Publisher {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public enum Event<Output, Failure> where Failure : Swift.Error {
  case value(Output)
  case failure(Failure)
  case finished
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CombineExt.Event : Swift.Equatable where Output : Swift.Equatable, Failure : Swift.Equatable {
  public static func == (lhs: CombineExt.Event<Output, Failure>, rhs: CombineExt.Event<Output, Failure>) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CombineExt.Event : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol EventConvertible {
  associatedtype Output
  associatedtype Failure : Swift.Error
  var event: CombineExt.Event<Self.Output, Self.Failure> { get }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CombineExt.Event : CombineExt.EventConvertible {
  public var event: CombineExt.Event<Output, Failure> {
    get
  }
}
public enum ObjectOwnership {
  case strong
  case weak
  case unowned
  public static func == (a: CombineExt.ObjectOwnership, b: CombineExt.ObjectOwnership) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func amb<Other>(_ other: Other) -> Combine.Publishers.Amb<Self, Other> where Other : Combine.Publisher, Self.Failure == Other.Failure, Self.Output == Other.Output
  public func amb<Other>(with others: Other...) -> Combine.AnyPublisher<Self.Output, Self.Failure> where Other : Combine.Publisher, Self.Failure == Other.Failure, Self.Output == Other.Output
  public func amb<Others>(with others: Others) -> Combine.AnyPublisher<Self.Output, Self.Failure> where Others : Swift.Collection, Self.Failure == Others.Element.Failure, Self.Output == Others.Element.Output, Others.Element : Combine.Publisher
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Collection where Self.Element : Combine.Publisher {
  public func amb() -> Combine.AnyPublisher<Self.Element.Output, Self.Element.Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  public struct Amb<First, Second> : Combine.Publisher where First : Combine.Publisher, Second : Combine.Publisher, First.Failure == Second.Failure, First.Output == Second.Output {
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, Second.Failure == S.Failure, Second.Output == S.Input
    public typealias Output = First.Output
    public typealias Failure = First.Failure
    public init(first: First, second: Second)
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Failure == Swift.Never {
  public func assign<Root>(to keyPath: Swift.ReferenceWritableKeyPath<Root, Self.Output>, on object: Root, ownership: CombineExt.ObjectOwnership = .strong) -> Combine.AnyCancellable where Root : AnyObject
  public func assign<Root1, Root2>(to keyPath1: Swift.ReferenceWritableKeyPath<Root1, Self.Output>, on object1: Root1, and keyPath2: Swift.ReferenceWritableKeyPath<Root2, Self.Output>, on object2: Root2, ownership: CombineExt.ObjectOwnership = .strong) -> Combine.AnyCancellable where Root1 : AnyObject, Root2 : AnyObject
  public func assign<Root1, Root2, Root3>(to keyPath1: Swift.ReferenceWritableKeyPath<Root1, Self.Output>, on object1: Root1, and keyPath2: Swift.ReferenceWritableKeyPath<Root2, Self.Output>, on object2: Root2, and keyPath3: Swift.ReferenceWritableKeyPath<Root3, Self.Output>, on object3: Root3, ownership: CombineExt.ObjectOwnership = .strong) -> Combine.AnyCancellable where Root1 : AnyObject, Root2 : AnyObject, Root3 : AnyObject
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Failure == Swift.Never {
  public func assign<Root1, Root2>(to keyPath1: Swift.ReferenceWritableKeyPath<Root1, Self.Output>, on object1: Root1, and keyPath2: Swift.ReferenceWritableKeyPath<Root2, Self.Output>, on object2: Root2) -> Combine.AnyCancellable
  public func assign<Root1, Root2, Root3>(to keyPath1: Swift.ReferenceWritableKeyPath<Root1, Self.Output>, on object1: Root1, and keyPath2: Swift.ReferenceWritableKeyPath<Root2, Self.Output>, on object2: Root2, and keyPath3: Swift.ReferenceWritableKeyPath<Root3, Self.Output>, on object3: Root3) -> Combine.AnyCancellable
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func combineLatest<Others>(with others: Others) -> Combine.AnyPublisher<[Self.Output], Self.Failure> where Others : Swift.Collection, Self.Failure == Others.Element.Failure, Self.Output == Others.Element.Output, Others.Element : Combine.Publisher
  public func combineLatest<Other>(with others: Other...) -> Combine.AnyPublisher<[Self.Output], Self.Failure> where Other : Combine.Publisher, Self.Failure == Other.Failure, Self.Output == Other.Output
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Collection where Self.Element : Combine.Publisher {
  public func combineLatest() -> Combine.AnyPublisher<[Self.Element.Output], Self.Element.Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.AnyPublisher {
  public init(_ factory: @escaping Combine.Publishers.Create<Output, Failure>.SubscriberHandler)
  public static func create(_ factory: @escaping Combine.Publishers.Create<Output, Failure>.SubscriberHandler) -> Combine.AnyPublisher<Output, Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  public struct Create<Output, Failure> : Combine.Publisher where Failure : Swift.Error {
    public typealias SubscriberHandler = (Combine.Publishers.Create<Output, Failure>.Subscriber) -> Combine.Cancellable
    public init(factory: @escaping Combine.Publishers.Create<Output, Failure>.SubscriberHandler)
    public func receive<S>(subscriber: S) where Output == S.Input, Failure == S.Failure, S : Combine.Subscriber
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers.Create {
  public struct Subscriber {
    public func send(_ input: Output)
    public func send(completion: Combine.Subscribers.Completion<Failure>)
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Failure == Swift.Never, Self.Output : CombineExt.EventConvertible {
  public func dematerialize() -> Combine.Publishers.Dematerialize<Self>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  public struct Dematerialize<Upstream> : Combine.Publisher where Upstream : Combine.Publisher, Upstream.Output : CombineExt.EventConvertible {
    public typealias Output = Upstream.Output.Output
    public typealias Failure = Upstream.Output.Failure
    public init(upstream: Upstream)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Upstream.Output.Failure, S.Input == Upstream.Output.Output
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func enumerated(initial: Swift.Int = 0) -> Combine.Publishers.Enumerated<Self>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  public struct Enumerated<Upstream> : Combine.Publisher where Upstream : Combine.Publisher {
    public typealias Output = (index: Swift.Int, element: Upstream.Output)
    public typealias Failure = Upstream.Failure
    public let upstream: Upstream
    public let initial: Swift.Int
    public init(upstream: Upstream, initial: Swift.Int = 0)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, Upstream.Failure == S.Failure, S.Input == Combine.Publishers.Enumerated<Upstream>.Output
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Output : Swift.Collection {
  public func filterMany(_ isIncluded: @escaping (Self.Output.Element) -> Swift.Bool) -> Combine.AnyPublisher<[Self.Output.Element], Self.Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Collection where Self.Element : Combine.Publisher {
  public func flatMapBatches(of size: Swift.Int) -> Combine.AnyPublisher<[Self.Element.Output], Self.Element.Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func flatMapFirst<P>(_ transform: @escaping (Self.Output) -> P) -> Combine.Publishers.FlatMap<Combine.Publishers.HandleEvents<P>, Combine.Publishers.Filter<Self>> where P : Combine.Publisher, Self.Failure == P.Failure
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func flatMapLatest<P>(_ transform: @escaping (Self.Output) -> P) -> Combine.Publishers.SwitchToLatest<P, Combine.Publishers.Map<Self, P>> where P : Combine.Publisher, Self.Failure == P.Failure
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func ignoreFailure(completeImmediately: Swift.Bool = true) -> Combine.AnyPublisher<Self.Output, Swift.Never>
  public func ignoreFailure<NewFailure>(setFailureType newFailureType: NewFailure.Type, completeImmediately: Swift.Bool = true) -> Combine.AnyPublisher<Self.Output, NewFailure> where NewFailure : Swift.Error
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func ignoreOutput<NewOutput>(setOutputType newOutputType: NewOutput.Type) -> Combine.Publishers.Map<Combine.Publishers.IgnoreOutput<Self>, NewOutput>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Output : Swift.Collection {
  public func mapMany<Result>(_ transform: @escaping (Self.Output.Element) -> Result) -> Combine.Publishers.Map<Self, [Result]>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func mapToResult() -> Combine.AnyPublisher<Swift.Result<Self.Output, Self.Failure>, Swift.Never>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func mapToValue<Value>(_ value: Value) -> Combine.Publishers.Map<Self, Value>
  public func mapToVoid() -> Combine.Publishers.Map<Self, Swift.Void>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func materialize() -> Combine.Publishers.Materialize<Self>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Failure == Swift.Never, Self.Output : CombineExt.EventConvertible {
  public func values() -> Combine.AnyPublisher<Self.Output.Output, Swift.Never>
  public func failures() -> Combine.AnyPublisher<Self.Output.Failure, Swift.Never>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  public struct Materialize<Upstream> : Combine.Publisher where Upstream : Combine.Publisher {
    public typealias Output = CombineExt.Event<Upstream.Output, Upstream.Failure>
    public typealias Failure = Swift.Never
    public init(upstream: Upstream)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Combine.Publishers.Materialize<Upstream>.Failure, S.Input == Combine.Publishers.Materialize<Upstream>.Output
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Collection where Self.Element : Combine.Publisher {
  public func merge() -> Combine.AnyPublisher<Self.Element.Output, Self.Element.Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func nwise(_ size: Swift.Int) -> Combine.AnyPublisher<[Self.Output], Self.Failure>
  public func pairwise() -> Combine.AnyPublisher<(Self.Output, Self.Output), Self.Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public typealias Partition = Combine.AnyPublisher<Self.Output, Self.Failure>
  public func partition(_ predicate: @escaping (Self.Output) -> Swift.Bool) -> (matches: Self.Partition, nonMatches: Self.Partition)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func prefix<S>(duration: S.SchedulerTimeType.Stride, tolerance: S.SchedulerTimeType.Stride? = nil, on scheduler: S, options: S.SchedulerOptions? = nil) -> Combine.AnyPublisher<Self.Output, Self.Failure> where S : Combine.Scheduler
}
public enum PrefixWhileBehavior {
  case inclusive
  case exclusive
  public static func == (a: CombineExt.PrefixWhileBehavior, b: CombineExt.PrefixWhileBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func prefix(while predicate: @escaping (Self.Output) -> Swift.Bool, behavior: CombineExt.PrefixWhileBehavior = .exclusive) -> Combine.AnyPublisher<Self.Output, Self.Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Output : Swift.Hashable {
  public func removeAllDuplicates() -> Combine.Publishers.Filter<Self>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Output : Swift.Equatable {
  public func removeAllDuplicates() -> Combine.Publishers.Filter<Self>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func removeAllDuplicates(by comparator: @escaping (Self.Output, Self.Output) -> Swift.Bool) -> Combine.Publishers.Filter<Self>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func retryWhen<RetryTrigger>(_ errorTrigger: @escaping (Combine.AnyPublisher<Self.Failure, Swift.Never>) -> RetryTrigger) -> Combine.Publishers.RetryWhen<Self, RetryTrigger, Self.Output, Self.Failure> where RetryTrigger : Combine.Publisher
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  @_hasMissingDesignatedInitializers public class RetryWhen<Upstream, RetryTrigger, Output, Failure> : Combine.Publisher where Upstream : Combine.Publisher, RetryTrigger : Combine.Publisher, Output == Upstream.Output, Failure == Upstream.Failure {
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, Upstream.Failure == S.Failure, Upstream.Output == S.Input
    @objc deinit
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Output == Swift.Never {
  public func setOutputType<NewOutput>(to outputType: NewOutput.Type) -> Combine.Publishers.Map<Self, NewOutput>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func share(replay count: Swift.Int) -> Combine.Publishers.Autoconnect<Combine.Publishers.Multicast<Self, CombineExt.ReplaySubject<Self.Output, Self.Failure>>>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Output == Swift.Bool {
  public func toggle() -> Combine.Publishers.Map<Self, Swift.Bool>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func withLatestFrom<Other, Result>(_ other: Other, resultSelector: @escaping (Self.Output, Other.Output) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Other, Result> where Other : Combine.Publisher, Self.Failure == Other.Failure
  public func withLatestFrom<Other, Other1, Result>(_ other: Other, _ other1: Other1, resultSelector: @escaping (Self.Output, (Other.Output, Other1.Output)) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output), Self.Failure>, Result> where Other : Combine.Publisher, Other1 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure
  public func withLatestFrom<Other, Other1, Other2, Result>(_ other: Other, _ other1: Other1, _ other2: Other2, resultSelector: @escaping (Self.Output, (Other.Output, Other1.Output, Other2.Output)) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output, Other2.Output), Self.Failure>, Result> where Other : Combine.Publisher, Other1 : Combine.Publisher, Other2 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure, Other1.Failure == Other2.Failure
  public func withLatestFrom<Other>(_ other: Other) -> Combine.Publishers.WithLatestFrom<Self, Other, Other.Output> where Other : Combine.Publisher, Self.Failure == Other.Failure
  public func withLatestFrom<Other, Other1>(_ other: Other, _ other1: Other1) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output), Self.Failure>, (Other.Output, Other1.Output)> where Other : Combine.Publisher, Other1 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure
  public func withLatestFrom<Other, Other1, Other2>(_ other: Other, _ other1: Other1, _ other2: Other2) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output, Other2.Output), Self.Failure>, (Other.Output, Other1.Output, Other2.Output)> where Other : Combine.Publisher, Other1 : Combine.Publisher, Other2 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure, Other1.Failure == Other2.Failure
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  public struct WithLatestFrom<Upstream, Other, Output> : Combine.Publisher where Upstream : Combine.Publisher, Other : Combine.Publisher, Upstream.Failure == Other.Failure {
    public typealias Failure = Upstream.Failure
    public typealias ResultSelector = (Upstream.Output, Other.Output) -> Output
    public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, Other.Failure == S.Failure
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func zip<Others>(with others: Others) -> Combine.AnyPublisher<[Self.Output], Self.Failure> where Others : Swift.Collection, Self.Failure == Others.Element.Failure, Self.Output == Others.Element.Output, Others.Element : Combine.Publisher
  public func zip<Other>(with others: Other...) -> Combine.AnyPublisher<[Self.Output], Self.Failure> where Other : Combine.Publisher, Self.Failure == Other.Failure, Self.Output == Other.Output
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Swift.Collection where Self.Element : Combine.Publisher {
  public func zip() -> Combine.AnyPublisher<[Self.Element.Output], Self.Element.Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public class CurrentValueRelay<Output> : CombineExt.Relay {
  public var value: Output {
    get
  }
  public init(_ value: Output)
  public func accept(_ value: Output)
  public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, S.Failure == Swift.Never
  public func subscribe<P>(_ publisher: P) -> Combine.AnyCancellable where Output == P.Output, P : Combine.Publisher, P.Failure == Swift.Never
  public func subscribe<P>(_ publisher: P) -> Combine.AnyCancellable where Output == P.Output, P : CombineExt.Relay
  @objc deinit
  public typealias Failure = Swift.Never
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public class PassthroughRelay<Output> : CombineExt.Relay {
  public init()
  public func accept(_ value: Output)
  public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, S.Failure == Swift.Never
  public func subscribe<P>(_ publisher: P) -> Combine.AnyCancellable where Output == P.Output, P : Combine.Publisher, P.Failure == Swift.Never
  public func subscribe<P>(_ publisher: P) -> Combine.AnyCancellable where Output == P.Output, P : CombineExt.Relay
  @objc deinit
  public typealias Failure = Swift.Never
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol Relay : Combine.Publisher where Self.Failure == Swift.Never {
  associatedtype Output
  func accept(_ value: Self.Output)
  func subscribe<P>(_ publisher: P) -> Combine.AnyCancellable where P : Combine.Publisher, Self.Output == P.Output, P.Failure == Swift.Never
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Failure == Swift.Never {
  public func subscribe<R>(_ relay: R) -> Combine.AnyCancellable where R : CombineExt.Relay, Self.Output == R.Output
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension CombineExt.Relay where Self.Output == Swift.Void {
  public func accept()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
final public class ReplaySubject<Output, Failure> : Combine.Subject where Failure : Swift.Error {
  public typealias Output = Output
  public typealias Failure = Failure
  public init(bufferSize: Swift.Int)
  final public func send(_ value: Output)
  final public func send(completion: Combine.Subscribers.Completion<Failure>)
  final public func send(subscription: Combine.Subscription)
  final public func receive<Subscriber>(subscriber: Subscriber) where Output == Subscriber.Input, Failure == Subscriber.Failure, Subscriber : Combine.Subscriber
  @objc deinit
}
extension CombineExt.ObjectOwnership : Swift.Equatable {}
extension CombineExt.ObjectOwnership : Swift.Hashable {}
extension CombineExt.PrefixWhileBehavior : Swift.Equatable {}
extension CombineExt.PrefixWhileBehavior : Swift.Hashable {}
